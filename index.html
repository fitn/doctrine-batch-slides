<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/fitn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section data-background="resources/pictures/background-plane_crash.jpg">
          <h2>The worst best idea:</h2>
          <h4>Doing batch with PHP and Doctrine</h4>

          <aside class="notes">
            Pourquoi ce sujet ?<br />
            PHP n'est pas fait pour le batch<br />
            Doctrine n'est pas fait pour ça non plus<br />
            Le but n'est pas de critiquer Doctrine ou de vous donner envie de l'utiliser<br />
            Réutiliser votre stack permet de garder vos entités, validateurs, events, queries, etc.<br />
            Réel retour d'XP sur des problèmes rencontrés<br />
            J'espère que ce retour vous apprendra quelques astuces et pourra vous aider<br />
          </aside>
        </section>

        <section class="vsep left">
          <div class="left">
            <img src="resources/me.jpg" />
          </div>
          <div class="right">
            <h2>Romain Monceau</h2>
            <ul class="contacts">
              <li><img src="resources/icons/twitter.png" class="icon" />@RomainMonceau</li>
              <li><img src="resources/icons/birthday.png" class="icon" />25 years old</li>
              <li><img src="resources/icons/php.png" class="icon" />+15 years</li>
              <li><img src="resources/icons/akeneo.png" class="icon" /> Lead Developer @Akeneo </li>
            </ul>
          </div>

          <aside class="notes">
            Beer addict<br />
          </aside>
        </section>

        <section data-background="resources/pictures/background-beers.jpg">
          <section>
            <h2>Site web</h2>
            <ul>
              <li>PHP 7</li>
              <li>MySQL 5.7</li>
              <li>Symfony 3.3</li>
              <li>Doctrine 2.5</li>
            </ul>
            <aside class="notes">
              Super site web qui recense toutes les bières, toutes les brasseries avec des commentaires des internautes !<br />
              Une fois le site prêt, je me suis rendu compte qu'il allait falloir que j'importe tout un tas de données.<br />
              Toute relation avec des projets existants ou ayant existés étant absolument fait exprès
            </aside>
          </section>

          <section>
            <div><img src="resources/icons/php.png" class="medium-icon" /></div>
            <h3>PHP is not done for batch processes</h3>

            <ul>
              <li>HTTP requests</li>
              <li>Timeout</li>
              <li>Take care at memory consumption</li>
            </ul>

            <aside class="notes">
              Comparaison avec le fonctionnement d'autres langages type Java?
            </aside>
          </section>

          <section>
            <div><img src="resources/icons/doctrine-orm.png" class="medium-icon" /></div>
            <h3>Doctrine has not been done for batch processes</h3>

            <img src="resources/img/doctrine_batch_doc.png" />
          </section>
        </section>

        <section data-background="resources/pictures/background-model.jpg">
          <section>
            <h2>Model presentation</h2>

            <img src="resources/img/doctrine_example_model.png" class="schema"/>

	          <aside class="notes">
		          Code unique<br />
		          Explain what is for!<br />
		          Relation manyToOne unidirectional from Beer entity<br />
	          </aside>
          </section>
          <section>
            <h4>Doctrine mapping: Beer.orm.yml</h4>

            <pre><code class="yml">BeerBundle\Entity\Beer:
  type: entity
  table: beer
  fields:
    id:
      [...]
    code:
      [...]
    name:
      [...]
    description:
      [...]
    percent:
      [...]
    quotation:
      [...]</code></pre>

            <aside class="notes">Just a specific repository class to search entity from code</aside>
          </section>

          <section>
            <h4>Doctrine mapping: Beer.orm.yml</h4>

            <pre><code class="yml">BeerBundle\Entity\Beer:
  type: entity
  table: beer
  manyToOne:
    brewery:
      targetEntity: BeerBundle\Entity\Brewery
      joinColumn:
        name: brewery_id
        referencedColumnName: id
    category:
      targetEntity: BeerBundle\Entity\Category
      joinColumn:
        name: category_id
        referencedColumnName: id
            </code></pre>
          </section>
        </section>

        <section data-background="resources/pictures/background-batch.jpg">

          <section>
            <h2>How doing batch?</h2>

            <img src="resources/img/diagram-batch-job.svg" class="schema"/>

            <aside class="notes">
              Ca se présente globalement comme un ETL (Extract / Transform / Load)<br />
              Stack maison largement inspiré d'Akeneo batch qui est un portage de Spring Batch (Java) en PHP<br />
              Tout cela est lancé depuis une commande Symfony
            </aside>
          </section>

          <section>
            <h4>Job implementation</h4>

            <pre><code class="php">public function execute() {
    while (!$stopExecution) {
        $readItem = $this->reader->read();
        if (null === $readItem) {
            $stopExecution = true; continue;
        }

        $processedItem = $this->processor->process($readItem);

        if (null !== $processedItem) {
            $itemsToWrite[] = $processedItem; $writeCount++;
            if (0 === $writeCount % $this->batchSize) {
                $this->writer->write($itemsToWrite);
                $itemsToWrite = [];
            }
        }
    }
}</code></pre>
          </section>

          <section>
            <h4>Reader</h4>
            <pre><code class="php">public function __construct($filepath) {
    $this->fd = fopen($filepath, 'r+');
    $this->headers = fgetcsv($this->fd, null, ';');
}

public function read() {
    $row = fgetcsv($this->fd, null, ';');
    if (false === $row) {
        return null;
    }
    return array_combine($this->headers, $row);
}

public function __destruct() {
    fclose($this->fd);
}</code></pre>
          </section>

          <section>
            <h4>Processor</h4>
            <pre><code class="php">public function process($item) {
    $category = $this->findOrCreateCategory($item['code']);
    $category->setName($item['name']);
    $category->setDescription($item['description']);

    return $category;
}

public function findOrCreateCategory(string $code) {
    $entity = $this->repository->findOneByIdentifier($code);
    if (null === $entity) {
        $entity = new Category();
        $entity->setCode($code);
    }

    return $entity;
}</code></pre>
          </section>

          <section>
            <h4>Writer</h4>

            <pre><code class="php">public function write(array $items) {
    $writeCount = 0;
    foreach ($items as $item) {
        $violations = $this->validator->validate($item);
        if ($violations->count() === 0) {
            $this->em->persist($item);
            $writeCount++;
        } else {
            foreach ($violations as $violation) {
                CommandLogger::error(...);
            }
        }
    }

    $this->em->flush();
}</code></pre>
          </section>
        </section>

        <section data-background="resources/pictures/background-brewery.jpg">
          <section>
            <h2>Import breweries (1000 lines)</h2>

            <pre><code class="yaml">code;name;description
id-quia;Dietrich Group;I know THAT
id-quia;Dietrich Group;I know THAT
abbey-ales;Abbey Ales Brewery;Abbey Ales Brewery
black-sheep;Black Sheep Brewery;A black sheep brewery
oakkham;Oakham Ales;The famous Oakham brewery</code></pre>
          </section>

          <section>
            <h4>Launch breweries import</h4>
            <pre class="fragment"><code class="bash">$ bin/console batch:import:brewery breweries.csv
Start: Memory: 12.58M
1001 entity written
End: Time: 25.77s - Memory: 29.36M - Diff: 16.78M</code></pre>

            <pre class="fragment"><code class="bash">$ bin/console batch:import:brewery breweries.csv --env=prod
Start: Memory: 10.49M
1001 entity written
End: Time: 22.2s - Memory: 20.97M - Diff: 10.48M</code></pre>

            <aside class="notes">
              By default, batch size = 1<br />
              Take care! By default, commands are launched in dev environment!!!<br />
            </aside>
          </section>

          <section>
            <h4>What is happening?</h4>

            <pre><code class="sql">[...]
DEBUG: SELECT [...] FROM brewery b0_ WHERE b0_.code LIKE 'id-quia'
DEBUG: SELECT [...] FROM brewery t0 WHERE t0.code = ? ["id-quia"]
DEBUG: "START TRANSACTION" [] []
DEBUG: INSERT INTO brewery [...] []
DEBUG: "COMMIT" [] []

DEBUG: SELECT [...] FROM brewery b0_ WHERE b0_.code LIKE 'abbey-ales'
DEBUG: SELECT [...] FROM brewery t0 WHERE t0.code = ? ["abbey-ales"]
DEBUG: "START TRANSACTION" [] []
DEBUG: INSERT INTO brewery [...] []
DEBUG: "COMMIT" [] []
[...]</code></pre>

            <aside class="notes">
              - 2 queries per item<br />
              - lot of transactions (1 per item)<br />
              Doctrine advices (and SGBD) is to flush sooner<br />
              Calculate the right ratio item per flush (You need to test)<br />
	            Possibilité de faire un begin transaction tout au début et d'avoir une grande transaction<br />
            </aside>
          </section>

          <section>
            <h4>Increase batch size to 100</h4>

            <pre class="fragment"><code class="bash">$ bin/console batch:import:brewery breweries.csv --env=prod
[Doctrine\DBAL\Exception\UniqueConstraintViolationException]
[Doctrine\DBAL\Driver\PDOException]
[PDOException]
  SQLSTATE[23000]: Integrity constraint violation:
    1062 Duplicate entry 'id-quia' for key 'searchunique_idx'</code></pre>

            <aside class="notes">
	            I relaunch the same import<br />
	            2 times the same code in my file<br />
            </aside>
          </section>

          <section>
	          <h4>Validation process: batch size 1</h4>

	          <img src="resources/img/doctrine_batch_schema_step1_batchsize_1.png" class="schema" />
          </section>

	        <section>
		        <h4>Validation process: batch size 100</h4>

		        <img src="resources/img/doctrine_batch_schema_step1_batchsize_100.png" class="schema" />

		        <aside class="notes">
			        Think about another way for validators!!!
		        </aside>
	        </section>

          <section>
            <h4>Rework validator</h4>

            <pre><code class="php">class UniqueEntityCodeValidator extends ConstraintValidator {
  private $codeSet = [];

  public function validate($entity, Constraint $constraint) {
    if (isset($this->codeSet[$entity->getCode()])) {
      $this->context
        ->buildViolation($constraint->message)
        ->setParameter('%unique_code%', $entity->getCode())
        ->addViolation();

      return;
    }
    $this->codeSet[$entity->getCode()] = $entity->getCode();
  }
}</code></pre>
          </section>

          <section>
            <h4>Relaunch the import now!</h4>
            <pre><code class="bash">Start: Memory: 10.49M
Entity "id-quia" not valid:
  The value "id-quia" is already set in another entity
1000 entity written
End: Time: 1.79s - Memory: 20.97M - Diff: 10.48M</code></pre>

	          <h5>Previous results</h5>
            <pre><code class="bash">Start: Memory: 10.49M
1001 entity written
End: Time: 22.2s - Memory: 20.97M - Diff: 10.48M</code></pre>
          </section>

        </section>

        <section data-background="resources/pictures/background-update.jpg">
          <section>
            <h2>Update Breweries</h2>

            <pre class="fragment"><code class="yaml">code;name
id-quia;"Dietrich GroupDietrich GroupDietrich Group[...]Dietrich Group"</code></pre>

            <aside class="notes">
              Another file with 1 line<br />
              This file contains a name longer than expected<br />
            </aside>
          </section>

          <section>
            <h4>Update breweries</h4>

            <pre><code class="bash">$ bin/console batch:import:brewery breweries_update.csv --env=prod
Memory: 10.49M
Entity "id-quia" not valid: This value is too long.
  It should have 100 characters or less.
0 entity written

[Doctrine\DBAL\Exception\DriverException]
[Doctrine\DBAL\Driver\PDOException]
[PDOException]
  SQLSTATE[22001]: String data, right truncated:
    1406 Data too long for column 'name' at row 1</code></pre>

            <aside class="notes">
              La validation a bien lieu est remonté, l'objet n'est pas persisté.<br />
	            Mais un update est quand même envoyé.<br />
              Celui-ci a pris du temps à être compris<br />
            </aside>
          </section>

          <section>
            <h4>What happens?!</h4>

            <img src="resources/img/doctrine_batch_schema_step_3.png" class="schema" />

            <aside class="notes">
              Explication du schéma + UOW<br />
              2 façons de faire pour corriger ce problème.<br />
              Détacher mon entity de l'UOW afin qu'elle ne soit pas prise en compte (souvent coûteux en temps de le faire ligne par ligne
            </aside>

          </section>

          <section>
            <h3>Change Tracking Policy</h3>

            <blockquote>
              "It is the process of determining what has changed in managed entities since the last time they were synchronized with the db"
            </blockquote>

            <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html">
              http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html
            </a>

            <aside class="notes">
              Defined per entity<br />
            </aside>
          </section>

          <section>
            <h3>Change Tracking Policy</h3>

            <ul>
              <li class="fragment">Deferred implicit (default)</li>
              <li class="fragment">Deferred explicit</li>
              <li class="fragment">Notify</li>
            </ul>

            <aside class="notes">
              Implicit: Doctrine detects the change by a property-by property comparison at commit time. EntityManager::flush(); everything<br />
              Explicit: Same but need to call explicitely EntityManager::persist(). More efficient ;)<br />
              Notify: You need to implement by yourself the changes using listeners. It's far more efficient.
            </aside>
          </section>

          <section>
            <h4>Deferred explicit implementation</h4>

            <pre><code class="yml">BeerBundle\Entity\Brewery:
  type: entity
  table: brewery
  repositoryClass: BeerBundle\Entity\Repository\EntityRepository
  changeTrackingPolicy: DEFERRED_EXPLICIT</code></pre>

            <aside class="notes">
              Plus explicite (comme son nom l'indique)<br />
              Plus efficace car Doctrine ne va checker les diff que sur ce qu'on lui a dit de persister<br />
              Cela résoud le problème fonctionnel mais il ne résoud pas réellement le problème de scalabilité mais nous verrons ça un peu plus tard.<br />
              La réponse à la scalabilité est de détacher cet objet de l'UOW<br />
              Je trouvais important de vous présenter ce fonctionnement pour mieux comprendre doctrine<br />
            </aside>

          </section>

          <section>
            <h4>Relaunch the job</h4>

            <pre><code class="bash">$ bin/console batch:import:brewery breweries_update.csv --env=prod
Memory: 10.49M
Entity "id-quia" not valid: This value is too long. It should have 100 characters or less.
0 entity written
End: Time: 0.05s - Memory: 14.68M - Diff: 4.19M</code></pre>

            <img src="resources/gif/dancing_zebra.gif" />

            <aside class="notes">
              Niveau performance, la différence se verra sur une grosse volumétrie<br />
              Si vous avez des erreurs et que vous ne persistez que la moitié des entités<br />
              Le calcul du changeset ne sera pas fait sur toutes ces entités
            </aside>
          </section>
        </section>

        <section data-background="resources/pictures/background-leak.jpg">
          <section>
            <h2>Memory leaks</h2>

            <pre class="fragment"><code class="yaml small">code;name;description;brewery;category
kronenbourg;Kronenbourg;A beer to piss;kronenbourg_brewery;piss
1664;1664;The high level of Kronenbourg brewery;kronenbourg_brewery;piss
stella;Stella Artois;A beer that does not respect its country;Artois;pils
33_export;33 Export;The best compitor of Kronenbourg;heineken;piss
bud_light;Budweiser;A Kronenbourg made by Americans;anheuser-bush;pale_lager</code></pre>
          </section>

          <section>
            <h4>Import beers (10000 lines)</h4>

            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Start: Memory: 10.49M
10000 entity written
End: Time: 20.18s - Memory: 92.27M - Diff: 81.78M</code></pre>

            <div class="fragment">
              <h4>Import beers (20000 lines)</h4>

              <pre><code class="bash">$ bin/console batch:import:beer beers_20k.csv --env=prod

PHP Fatal error:
  Allowed memory size of 134217728 bytes exhausted
  (tried to allocate 20480 bytes)</code></pre>
            </div>

            <aside class="notes">
              Useless to increase PHP memory limit,<br />
              it will probably break later with a bigger file
            </aside>

          </section>

          <section>
            <h4>Memory consumption</h4>

            <img src="resources/img/chart-doctrine-memory-leak.png" />

            <aside class="notes">
              Every 5000 items<br />
              300k items
            </aside>
          </section>

          <section data-background="resources/gif/truck_explosion.gif"></section>

          <section>
            <h3>Explanation memory leak problems</h3>

            <ul>
              <li class="fragment">Increase memory usage</li>
              <li class="fragment">GC is run more often...</li>
              <li class="fragment">and for nothing!</li>
              <li class="fragment">Decrease performance</li>
            </ul>

            <aside class="notes">
              3. not able to free memory<br />
              4. It leads to an increase of CPU usage of the process<br />
              Maybe deep into memory usage and garbage collector in PHP<br />
              How to free the memory of an object<br />
              No object duplication<br />
              It's a link on its address and then a reference counter to know how many time an object is used<br />
              When object is not used anymore, it could be free<br />
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-meminfo.jpg">

          <section>
            <h2>php-meminfo</h2>

            <ul>
              <li>Give insight about PHP memory content</li>
              <li>Free & open source PHP extension</li>
              <li><a href="https://github.com/BitOne/php-meminfo">https://github.com/BitOne/php-meminfo</a></li>
            </ul>

            <aside class="notes">
              License MIT<br />
              Its main goal is to help you understand memory leaks: <br />
              by looking at data present in memory, you can better understand your application behaviour.<br />
              We will take a look deeper using a PHP extension named php-meminfo<br />
            </aside>

          </section>

          <section>
            <h3>php-meminfo: How it works?</h3>

            <ol>
              <li class="fragment">Dump memory content</li>
              <li class="fragment">Analyze content (summary)</li>
              <li class="fragment">Analyze memory for an object type</li>
              <li class="fragment">Analyze memory path for a specific object</li>
            </ol>
          </section>

          <section>
            <h4>Dump memory content</h4>

            <pre><code class="php">// EntityWriter
$this->em->flush();
meminfo_info_dump(fopen('/tmp/doctrine_batch.log', 'w'));</code></pre>

            <pre class="fragment"><code class="json">{
  "header": {
    "memory_usage":89735424,
    "memory_usage_real":92274688,
    "peak_memory_usage":90107432,
    "peak_memory_usage_real":92274688
  },
  "items": {
    "0x7f64be256100" : {
      "type" : "array",
      "size" : "72",
      "symbol_name" : "_GET",
      "is_root" : true,
      "frame" : "BatchBundle\\Job\\Job->execute()",
      "children" : {}
    },
    ...
  }
}</code></pre>

            <aside class="notes">
              Expliquer pourquoi le dump est fait là<br />
              Sorte de fin d'une boucle.<br />
              Et puis ça m'arrange car c'est là qu'est le memory leak
            </aside>
          </section>

          <section>
            <h4>Summarize content</h4>

            <pre><code class="bash">$ bin/analyzer summary /tmp/doctrine_batch.log</code></pre>

            <div class="fragment">
              <table class="small">
                <thead>
                <tr>
                  <td>Type</td>
                  <td>Instances Count</td>
                </tr>
                </thead>
                <tbody>
                <tr><td>BeerBundle\Entity\Brewery</td><td>21000</td></tr>
                <tr><td>BeerBundle\Entity\Category</td><td>20139</td></tr>
                <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
                <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
                <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
                <tr><td>BeerBundle\Entity\Beer</td><td>10000</td></tr>
                </tbody>
              </table>
            </div>

            <aside class="notes">
              Could be Proxies\__CG__\BeerBundle\Entity\Brewery<br />
              La taille mémoire cumulée des objets est également disponible mais masquée ici
            </aside>
          </section>

          <section>
            <h4>Analyze memory for an object type</h4>

            <pre><code class="bash smaller">$ bin/analyzer query -f "class=BeerBundle\\Entity\\Beer" -v /tmp/doctrine_batch.log</code></pre>

            <div class="fragment">
              <table>
                <thead>
                <tr>
                  <td>Item ids</td>
                  <td>Item data</td>
                  <td>Children</td>
                </tr>
                </thead>
                <tbody>
                <tr>
                  <td>0x7f64ab801028</td>
                  <td>
                    Type: object<br />
                    Class: BeerBundle\Entity\Beer<br />
                    [...]
                  </td>
                  <td>
                    id: 0x7f64a8d354e0<br />
                    code: 0x7f64a8d35500<br />
                    [...]<br />
                    brewery: 0x7f64a8d355a0<br />
                    category: 0x7f64a8d355c0
                  </td>
                </tr>
                </tbody>
              </table>
            </div>
          </section>

          <section>
            <h4>Analyze memory path for a specific object</h4>

            <pre><code class="bash">$ bin/analyzer ref-path /tmp/doctrine_batch.log 0x7f64ab801028
Found 3 paths
0x7f64ab801028
&uarr;
1 (0x7f64afa4a920)
&uarr;
BeerBundle\Entity\Beer (0x7f64a8c65c80)
&uarr;
identityMap (0x7f64a8c6d320)
&uarr;
unitOfWork (0x7f64afdbe7c0)
&uarr;
doctrine.orm.default_entity_manager (0x7f64af9c08e0)
&uarr;
services (0x7f64af9c1280)
&uarr;
container (0x7f64be256280)</code></pre>

            <aside class="notes"></aside>
          </section>

          <section>
            <img src="resources/gif/oh_my_god_afraid.gif" />

            <aside class="notes">
              Ask if everything is clear!!!
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-deep_uow.jpg">
          <section>
            <h2>Deep into the UOW</h2>
          </section>

          <section>
            <h3>The identity map</h3>
            <div>
              <ul>
                <li>Stores references to all managed entities</li>
                <li>Entities are grouped by their class name</li>
                <li>Avoid entity duplication</li>
              </ul>
            </div>

            <div class="fragment">
              <pre><code class="php">$this->identityMap[$className][$idHash] = $entity;</code></pre>

              <pre><code class="php">$breweryA = $breweryRepo->findOneBy(['code' => 'id-quia']);
$breweryB = $breweryRepo->findOneBy(['name' => 'Dietrich Group']);
$this->assertSame($breweryA, $breweryB);</code></pre>
            </div>

            <aside class="notes">
              4 status of your entity (New, Managed, Detached, Removed)<br />
              Cache niveau 2 pour identityMap?<br/>
	            Ne signifie pas qu'il n'y a pas de query SQL<br />
            </aside>

          </section>

          <section>
            <h3>Detach versus clear</h3>

            3 ways to remove from the UOW:

            <pre class="fragment"><code class="php">$em->detach($entity);</code></pre>
            <pre class="fragment"><code class="php">$em->clear('BeerBundle\Entiy\Beer');</code></pre>
            <pre class="fragment"><code class="php">$em->clear();</code></pre>

            <aside class="notes">
              detach: Detach an entity from the UOW. Does not remove updateCollections, removeCollections, etc. done by commit();<br />
              clear($className): Detach all entities of the class name<br />
              clear(): Clears UOW
            </aside>
          </section>

          <section>
            <h4>Detach entities</h4>

            <pre><code class="php">// EntityWriter
$this->em->flush();
$this->em->clear('BeerBundle\Entity\Beer');
// or loop on items and call detach
foreach ($items as $item) {
  $this->em->detach($item);
}</code></pre>

            <h4>Previously:</h4>
            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
End: Time: 20.18s - Memory: 92.27M - Diff: 81.78M</code></pre>

            <div class="fragment">
              <h4>Now:</h4>
              <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
End: Time: 20.91s - Memory: 69.21M - Diff: 56.63M</code></pre>
            </div>

            <aside class="notes">Same perf between loop detach and clear($className)</aside>
          </section>

          <section>
            <h4>Analyze memory</h4>

            <table class="small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
              <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
              <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
              <tr><td>BeerBundle\Entity\Brewery</td><td>1000</td></tr>
              <tr><td>BeerBundle\Entity\Category</td><td>139</td></tr>
              </tbody>
            </table>

            <aside class="notes">
              Categories and Breweries still in memory but, this number won't increase!
            </aside>
          </section>

          <section>
            <h3>Detach entities</h3>

            <img src="resources/gif/the_office_oh_yeah.gif" />

            <ul class="fragment">
              <li>Categories and Breweries are not detached</li>
              <li>No cascade detach (ManyToOne)</li>
              <li>Not the same lifecycle</li>
            </ul>

            <aside class="notes">
              Categories and Breweries exist without Beers<br />
              Don't want to cascade detach<br />
              Categories needs to stay in the UOW as they can be used by another Beer
            </aside>
          </section>

          <section>
            <h4>Clear UOW</h4>
            <pre><code class="php">// EntityWriter
$this->em->flush();
$this->em->clear();</code></pre>

            <h4>Previously:</h4>
            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
End: Time: 20.91s - Memory: 69.21M - Diff: 56.63M</code></pre>

            <div class="fragment">
              <h4>Now:</h4>
              <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
End: Time: 20.52s - Memory: 67.11M - Diff: 54.53M</code></pre>
            </div>
          </section>

          <section>
            <h4>Clear UOW</h4>
            <table class="small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
              <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
              <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
              </tbody>
            </table>

            <img src="resources/gif/barney_stinson_good.gif" />

            <aside class="notes">
              2M less than previous execution<br />
              No more Brewery nor Category<br />
              Not necessary to clear the whole UOW in this case<br />
	            10000 beers + 1000 breweries + 139 categories
            </aside>
          </section>
        </section>

        <section data-background="resources/pictures/background-hunt.jpg">
	        <section>
		        <h2>Let's hunt last memory leaks</h2>

		        <ul class="fragment">
			        <li class="fragment grow">SingleSelectExecutor</li>
			        <li class="fragment grow">ResultSetMapping</li>
			        <li class="fragment grow">ParserResult</li>
		        </ul>

            <aside class="notes">
              1. Executes SQL statement from DQL select statement<br />
              2. Maps results set of SQL query to Doctrine results<br />
              3. Encapsulates results from DQL parsing
            </aside>
	        </section>

	        <section>
		        <h4>Let's hunt last memory leaks</h4>

		        Analyze the memory with php-meminfo:

		        <pre><code>Path from 0x7fa5eaa56280
0x7fa5d8f14c00
&uarr;
_resultSetMapping (0x7fa5dc2af5c8)
&uarr;
0 (0x7fa5d9a11000)
&uarr;
sf_orm_default_a1536898803dafe5169a1bd008aad667f3b84c092cc24b9f4a3483342a35e6d6[72581bcf67100f31f4179c031c0fa291][1] (0x7fa5d8ee45e0)
&uarr;
data (0x7fa5dc5b9b00)
&uarr;
doctrine_cache.providers.doctrine.orm.default_query_cache (0x7fa5dc1d3060)
&uarr;
services (0x7fa5dc1d3780)
&uarr;
container (0x7fa5eaa56280)</code></pre>

		        <aside class="notes">
              Object linked to ORM\Query
            </aside>
	        </section>

	        <section>
		        <h4>Dedicated repository</h4>

		        <pre><code class="php">public function findOneByIdentifier(string $code) {
    $qb = $this->createQueryBuilder('c');
    $qb->andWhere(
        $qb->expr()->like('c.code', $qb->expr()->literal($code))
    );

    $results = $qb->getQuery()->execute();
    //...
    return $results[0];
}</code></pre>

            <img src="resources/gif/mister_bean_nawak.gif" class="fragment" />

	        </section>

	        <section>
		        <h4>How to query entities?!</h4>

		        <pre><code class="php">$qb = $this->createQueryBuilder('c');
$qb->andWhere(
  $qb->expr()->like('c.code', $qb->expr()->literal($code))
);

$results = $qb->getQuery()->execute();</code></pre>

            <div class="fragment">
              <h4>DQL</h4>
              <pre><code class="sql smaller">SELECT c FROM BeerBundle\Entity\Beer c WHERE c.code LIKE 'dolorum-aliquid-maiores'</code></pre>
            </div>
	        </section>

	        <section>
		        <h4>How to query entities?!</h4>

		        <pre><code class="php">$qb = $this->createQueryBuilder('c');
$qb->andWhere(
  $qb->expr()->like('c.code', ':code')
);
$qb->setParameter('code', $code);

$results = $qb->getQuery()->execute();</code></pre>

            <div class="fragment">
              <h4>DQL</h4>
              <pre><code class="sql">SELECT c FROM BeerBundle\Entity\Beer c WHERE c.code LIKE :code</code></pre>
            </div>

	        </section>

          <section>
            <h4>How to query entities?!</h4>

            <pre><code class="php">public function findOneByIdentifier(string $code) {
    return $this->findOneBy(['code' => $code]);
}</code></pre>
            <ul>
              <li>Uses BasicEntityPersister</li>
              <li>Only work on a single table</li>
            </ul>

            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
End: Time: 14.38s - Memory: 14.68M - Diff: 3.89M</code></pre>

            <aside class="notes">
              Persister instead of create DQL queries<br />
              Far more efficient<br />
              More about performance<br />
              14.68M
            </aside>
          </section>

          <section>
            <h4>Analyze memory</h4>

            <pre><code class="bash">$ bin/console batch:import:beer beers_1M.csv --env=prod
Memory: 10.49M
End: Time: 2297.23s - Memory: 14.68M - Diff: 4.19M</code></pre>

            <img src="resources/gif/waouh.gif" />

            <aside class="notes">
              Juste une petite modification sur le validateur<br />
              puisqu'il faut nettoyer le tableau de code uniques après chaque flush<br />
              No more memory leak at this point!<br />
              Don't know why there is so much entities of these types
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-import-summary.jpg">
          <section>
            <h2>Mission accomplished!</h2>

            <img src="resources/gif/cat_shakes.gif" />
          </section>

          <section>
            <h3>In a nutshell</h3>
            <ul>
              <li class="fragment">Use production environment</li>
              <li class="fragment">Find the right moment to flush</li>
              <li class="fragment">Rework validation</li>
              <li class="fragment">Change Tracking Policy</li>
              <li class="fragment">Clear UOW</li>
              <li class="fragment">Take care at your queries</li>
            </ul>
          </section>
        </section>

        <section data-background="resources/pictures/background-export.jpg">
          <section>
            <h2>What about export!</h2>
          </section>

          <section>
            <h4>Reader</h4>

            <pre><code class="php">public function read() {
    if (null === $this->results) {
        $this->results = $this->getResults();
    }

    if (null !== $result = $this->results->current()) {
        $this->results->next();
    }

    return $result;
}

private function getResults() {
    $results = $this->repository->findAll();

    return new \ArrayIterator($results);
}</code></pre>
          </section>

          <section>
            <h4>Launch the export</h4>

            <pre><code class="bash">$ bin/console batch:export:beer beers.csv --env=prod
Memory: 10.49M
End: Time: 1.05s - Memory: 46.14M - Diff: 35.65M</code></pre>

            <table class="fragment small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Brewery</td><td>21000</td></tr>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Category</td><td>20139</td></tr>
              <tr><td>BeerBundle\Entity\Beer</td><td>10000</td></tr>
              </tbody>
            </table>
          </section>

          <section>
            <h4>Clear the UOW</h4>

            <pre><code class="php">private function getResults()
{
    $results = $this->repository->findAll();
    $this->repository->clear();

    return new \ArrayIterator($results);
}</code></pre>

            <pre class="fragment"><code class="bash">bin/console batch:export:beer beers.csv --env=prod
Memory: 10.49M
End: Time: 1.32s - Memory: 46.14M - Diff: 35.65M</code></pre>

            <table class="fragment small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Brewery</td><td>1000</td></tr>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Category</td><td>139</td></tr>
              </tbody>
            </table>

            <aside class="notes">
              Clear since repository do a clear($className)
            </aside>
          </section>

          <section>
            <h2>Find All</h2>

            <img src="resources/gif/barney_stinson_no.gif" />

            <div class="fragment">
              <ul>
                <li>Take care about findAll</li>
                <li>At least use findBy method</li>
              </ul>

              <pre><code class="php smaller">public function findBy(array $criteria, array $orderBy, $limit, $offset);</code></pre>
            </div>

            <aside class="notes">
              1. This should never be used <br />
              1. Si create autorisé, vous devez faire attention à la volumétrie<br />
              2. findBy uses offset and limit<br />
            </aside>
          </section>

          <section>
            <h4>How to do SQL query on huge table?!</h4>

            <ul>
              <li>Read offset/limit</li>
              <li>Database cursor</li>
              <li>Search after</li>
            </ul>
          </section>

          <section class="vsep left">
            <div class="left">
              <img src="resources/img/sql_read_offset_limit.png" />
            </div>

            <div class="right">
              <h4>Read offset/limit</h4>
              <ul>
                <li>Linear increase</li>
                <li>Exponential cost per volume</li>
              </ul>
            </div>

            <aside class="notes"></aside>
          </section>

          <section>
            <h4>Read offset/limit</h4>

            <pre><code class="sql">mysql> SELECT * FROM beer;
1611768 rows in set (3,92 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 0, 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 100000, 100;
100 rows in set (0,09 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 1000000, 100;
100 rows in set (0,83 sec)</code></pre>

            <aside class="notes">
              Besoin de lire le 1er M de lignes pour renvoyer les 100 prochaines<br />
              $qb->setFirstResult et setMaxResult en doctrine
            </aside>
          </section>

          <section class="vsep left">
            <div class="left">
              <img src="resources/img/sql_read_db_cursor.png" />
            </div>

            <div class="right">
              <h4>Database cursor</h4>
              <ul>
                <li>No increase</li>
                <li>Linear cost per volume</li>
              </ul>
            </div>

            <aside class="notes">
              once the query had been launched<br />
              the results are made available one by one to the client that launched the query
            </aside>
          </section>

          <section>
            <h4>Database cursor</h4>

            <pre><code class="php">public function __construct(EntityManager $em) {
        $em->getConnection()
            ->getWrappedConnection()
            ->setAttribute(\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
        $this->repository = $em->getRepository('BeerBundle\Entity\Beer');
}

public function read() {
    //...
    $result = $this->results->next();
    if (null !== $result) {
        if (++$this->readCount % 100 === 0)
            $this->repository->clear();
        return $result[0];
    }
}

private function getResults() {
    $qb = $this->repository->createQueryBuilder('b');
    return $qb->getQuery()->iterate();
}</code></pre>
          </section>

          <section>
            <h3>Database cursor</h3>

            <pre><code class="bash">bin/console batch:export:beer beers.csv --env=prod
End: Time: 112.78s - Memory: 14.68M - Diff: 4.19M</code></pre>

            <div>Inconvenience: Once cursor is opened, not possible to have any other SELECT operations</div>

            <pre><code class="bash smaller">[PDOException]
  SQLSTATE[HY000]: [...]Cannot execute queries while other unbuffered queries are active.</code></pre>

            <aside class="notes">
              On peut imaginer loader en cache les objets catégories et breweries avant d'itérer<br />
              Avec un findAll()...
            </aside>
          </section>

          <section class="vsep left">
            <h4>Search after</h4>

            <div class="left">
              <img src="resources/img/sql_read_search_after.png" />
            </div>

            <div class="right">
              <ul>
                <li>No increase</li>
                <li>Linear cost per volume</li>
              </ul>
            </div>

            <aside class="notes">
              Le problème du Offset-limit c'est de tout relire depuis le début<br />
              Si on recherche après notre dernier résultat, on enlève ce problème
            </aside>
          </section>

          <section>
            <h4>Search after</h4>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 0 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 100000 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 1000000 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <aside class="notes">
              A vous d'implémenter ça dans le code maintenant :)
            </aside>
          </section>

          <section>
            <h4>Search after</h4>

            <pre><code class="php">private function getResults($id = 0) {
    $qb = $this->repository->createQueryBuilder('b');
    $qb
        ->where($qb->expr()->gt('b.id', ':id'))
        ->orderBy('b.id')
        ->setMaxResults(100)
        ->setParameter('id', $id);

    $this->results = $qb->getQuery()->execute();
}</code></pre>

            <pre><code class="bash fragment">$ bin/console batch:export:beer beers.csv --env=prod
End: Time: 132.91s - Memory: 14.68M - Diff: 4.19M</code></pre>

            <aside class="notes">
              20 secondes de plus qu'avec le database cursor<br />
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-whats_next.jpg">
          <h2>What's next?</h2>

          <ul>
            <li>Multi import</li>
            <li>Improve performance</li>
            <li>Mass Delete</li>
          </ul>

          <aside class="notes">
            1. Import brewery + beers at the same time<br />
            2. Change Tracking Policy using notify
          </aside>
        </section>

        <section data-background="resources/pictures/background-thanks.jpg">

          <h2>Thank you</h2>

          <img src="resources/gif/piti_chat_milk.gif" height="300" />

          <a href="https://github.com/fitn/doctrine-batch/">https://github.com/fitn/doctrine-batch/</a>

          <aside class="notes">
            Retour d'xp d'Akeneo<br />
            J'espère que vous avez appris quelques petits trucs<br />
            Et que vous aurez envie de creuser un peu plus doctrine
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>

  </body>
</html>
