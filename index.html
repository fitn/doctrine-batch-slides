<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/fitn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section data-background="resources/pictures/background-plane_crash.jpg">
          <section class="vsep left">
            <div class="left">
              <img src="resources/me.jpg" />
            </div>
            <div class="right">
              <h2>Romain Monceau</h2>
              <ul class="contacts">
                <li><img src="resources/icons/twitter.png" class="icon" />@RomainMonceau</li>
                <li><img src="resources/icons/birthday.png" class="icon" />~ 25 years old</li>
                <li><img src="resources/icons/php.png" class="icon" />+15 years</li>
                <li><img src="resources/icons/akeneo.png" class="icon" /> Lead Developer @Akeneo </li>
              </ul>
            </div>

            <aside class="notes">
              Akeneo<br />
              PIM<br />
              Volumétrie<br />
              Retour d'XP<br />
            </aside>
          </section>

          <section>
            <h2>The worst best idea:</h2>
            <h4>Doing batch with PHP and Doctrine</h4>

            <aside class="notes">
              Problèmes rencontrés chez Akeneo<br />
              Qui connaît Doctrine ? Qui travaille tous les jours avec Doctrine ? Sur un projet l'utilisant ?<br />
              Pas polémiquer ni évangéliser<br />
            </aside>
          </section>

          <section>
            <div><img src="resources/icons/php.png" class="medium-icon" /></div>
            <h3>PHP is not done for batch processes</h3>

            <ul>
              <li>HTTP requests</li>
              <li>Timeout</li>
              <li>Take care at memory consumption</li>
            </ul>

            <aside class="notes">
              Mémoire par process<br />
            </aside>
          </section>

          <section>
            <div><img src="resources/icons/doctrine-orm.png" class="medium-icon" /></div>
            <h3>Doctrine has not been done for batch processes</h3>

            <img src="resources/img/doctrine_batch_doc.png" />

            <aside class="notes">
              First error! Ne pas lire la doc<br />
              Pester sur Doctriner pour corriger NOS erreurs<br />
              Puis on s'est rendu compte qu'on l'utilisait mal<br />
              Ne pas reprocher à un outil de ne pas faire ce pour quoi il n'est pas fait<br />
            </aside>
          </section>
        </section>

        <section data-background="resources/pictures/background-model.jpg">
          <section>
            <h2>Site web</h2>
            <ul>
              <li>PHP 7</li>
              <li>MySQL 5.7</li>
              <li>Symfony 3.3</li>
              <li>Doctrine 2.5</li>
            </ul>
            <aside class="notes">
              Bière =)<br />
              Appli pour illustrer ma prez<br />
              Site web avec Bières et Brasseries<br />
            </aside>
          </section>

          <section>
            <h2>Model presentation</h2>

            <img src="resources/img/doctrine_example_model.png" class="schema"/>

	          <aside class="notes">
		          Code unique<br />
		          Explain what is for!<br />
		          Relation manyToOne unidirectional from Beer entity<br />
	          </aside>
          </section>

          <section>
            <h4>Doctrine mapping: Beer.orm.yml</h4>

            <pre><code class="yml">BeerBundle\Entity\Beer:
  type: entity
  table: beer
  repositoryClass: BeerBundle\Entity\Repository\EntityRepository
  indexes:
      searchcode_idx:
          columns:
              - code
  uniqueConstraints:
      searchunique_idx:
          columns:
              - code</code></pre>

            <aside class="notes">Just a specific repository class to search entity from code</aside>
          </section>

          <section>
            <h4>Entity Repository</h4>

            <pre><code class="php">
  // BeerBundle\Entity\Repository\EntityRepository

  public function findOneByIdentifier(string $code)
  {
      $qb = $this->createQueryBuilder('c');
      $qb->andWhere(
          $qb->expr()->eq('c.code', $qb->expr()->literal($code))
      );


      $results = $qb->getQuery()->execute();
      // ...

      return $results[0];
  }
            </code></pre>
          </section>

          <section>
            <h4>Doctrine mapping: Beer.orm.yml</h4>

            <pre><code class="yml">BeerBundle\Entity\Beer:
  type: entity
  table: beer
  repositoryClass: BeerBundle\Entity\Repository\EntityRepository
  fields:
    id:
      [...]
    code:
      [...]
    name:
      [...]
    description:
      [...]
    percent:
      [...]
    quotation:
      [...]</code></pre>

            <aside class="notes">

            </aside>
          </section>

          <section>
            <h4>Doctrine mapping: Beer.orm.yml</h4>

            <pre><code class="yml">BeerBundle\Entity\Beer:
  type: entity
  table: beer
  manyToOne:
    brewery:
      targetEntity: BeerBundle\Entity\Brewery
      joinColumn:
        name: brewery_id
        referencedColumnName: id
    category:
      targetEntity: BeerBundle\Entity\Category
      joinColumn:
        name: category_id
        referencedColumnName: id
            </code></pre>
          </section>

          <section>
            <h4>Beer application is ready!</h4>

            <h4 class="fragment">Oh wait! We need to import data!</h4>

            <div class="fragment"><img src="resources/gif/piti_chat_milk.gif" height="300" /></div>

            <aside class="notes">
              Create 1 = Create 10k<br />
              Toute similitude avec des projets existants est absolument fait exprès<br />
              Contrainte de temps, projet déjà fait, limiter les régressions, pas de contraintes de perf...<br />
              Reuse stack is not bad (events, entities, mapping, queries, validators, etc.)<br />
              Réduction du temps + limite des régressions<br />
              A ce moment volumétrie cible = quelques milliers de références...<br />
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-brewery.jpg">
          <section>
            <h2>Import breweries (1000 lines)</h2>

            <pre><code class="yaml">code;name;description
abbey-ales;Abbey Ales Brewery;Abbey Ales Brewery
black-sheep;Black Sheep Brewery;A black sheep brewery
oakkham;Oakham Ales;The famous Oakham brewery</code></pre>

            <aside class="notes">
              Generate file with Faker lib from François Zaninotto<br />
              Bdd vierge => CREATE<br />
              Filepath as input<br />
            </aside>
          </section>

          <section>
            <h4>Command to import breweries</h4>
            <pre><code class="php">// Read file content
$fd = fopen($filepath, 'r+');
$headers = fgetcsv($fd, null, ';');

while ($csvRow = fgetcsv($fd, null, ';')) {
    $csvRow = array_combine($headers, $csvRow);

    // Process data row
    $entity = $this->process($csvRow);

    // Validate entity
    $violations = $this->getValidator()->validate($entity);
    if ($violations->count() === 0) {
        // Write entity
        $this->getEntityManager()->persist($entity);
        $this->getEntityManager()->flush();
    } else {
        $this->printViolations($violations, $entity);
    }
}</code></pre>

            <aside class="notes">
              `process()` permet d'instancier ou de récupérer de la base un objet<br />
              Puis mettre à jour ses valeurs<br />
              Voir slide suivant<br />
            </aside>
          </section>

          <section>
            <h4>Command to import breweries</h4>
            <pre><code class="php">private function process(array $item)
{
    $brewery = $this->findOrCreateBrewery($item['code']);
    $brewery->setName($item['name']);
    $brewery->setDescription($item['description']);
    $brewery->setAddress($item['address']);
    // ...

    return $brewery;
}

private function findOrCreateBrewery(string $code)
{
    $entity = $this->getRepository()->findOneByIdentifier($code);
    if (null === $entity) {
        $entity = new Brewery();
        $entity->setCode($code);
    }

    return $entity;
}</code></pre>

            <aside class="notes">
            </aside>
          </section>

          <section>
            <h4>Launch breweries import</h4>
            <pre><code class="bash">$ bin/console batch:import:brewery breweries.csv
Memory: 8.39M
1001 entity written
Time: 23.77s - Memory: 29.36M - Diff: 20.97M</code></pre>

            <pre class="fragment"><code class="bash">$ bin/console batch:import:brewery breweries.csv --env=prod
Memory: 6.29M
1001 entity written
Time: 21.24s - Memory: 20.97M - Diff: 14.68M</code></pre>

            <aside class="notes">
              Take care! By default, commands are launched in dev environment!!!<br />
            </aside>
          </section>

          <section>
            <h4>What is happening?</h4>

            <pre><code class="sql">[...]
DEBUG: SELECT [...] FROM brewery b0_ WHERE b0_.code = 'id-quia'
DEBUG: SELECT [...] FROM brewery t0 WHERE t0.code = ? ["id-quia"]
DEBUG: "START TRANSACTION" [] []
DEBUG: INSERT INTO brewery [...] []
DEBUG: "COMMIT" [] []

DEBUG: SELECT [...] FROM brewery b0_ WHERE b0_.code LIKE 'abbey-ales'
DEBUG: SELECT [...] FROM brewery t0 WHERE t0.code = ? ["abbey-ales"]
DEBUG: "START TRANSACTION" [] []
DEBUG: INSERT INTO brewery [...] []
DEBUG: "COMMIT" [] []
[...]</code></pre>

            <aside class="notes">
              - 2 queries per item (findOneBy -> l'autre c'est pour la validation et l'unicité)<br />
              - lot of transactions (1 per item)<br />
              Doctrine advices (and SGBD) is to flush sooner<br />
              Calculate the right ratio item per flush (You need to test)<br />
	            Possibilité de faire un begin transaction tout au début et d'avoir une grande transaction<br />
            </aside>
          </section>

          <section>
            <h4>Increase batch size to 100</h4>

            <pre><code class="php">// Write entity
$this->getEntityManager()->persist($entity);
if (0 === ++$writeCount % 100) {
    $this->getEntityManager()->flush();
}</code></pre>

            <aside class="notes">
              I relaunch the same import<br />
              2 times the same code in my file<br />
            </aside>
          </section>

          <section>
            <h4>Increase batch size to 100</h4>

            <pre><code class="bash">$ bin/console batch:import:brewery breweries.csv --env=prod
[Doctrine\DBAL\Exception\UniqueConstraintViolationException]
[Doctrine\DBAL\Driver\PDOException]
[PDOException]
  SQLSTATE[23000]: Integrity constraint violation:
    1062 Duplicate entry 'id-quia' for key 'searchunique_idx'</code></pre>

            <aside class="notes">
              I relaunch the same import<br />
              2 times the same code in my file<br />
            </aside>
          </section>

          <section>
	          <h4>Validation process: batch size 1</h4>

	          <img src="resources/img/doctrine_batch_schema_step1_batchsize_1.png" class="schema" />

            <aside class="notes">
              Explain UOW<br />
            </aside>
          </section>

	        <section>
		        <h4>Validation process: batch size 100</h4>

		        <img src="resources/img/doctrine_batch_schema_step1_batchsize_100.png" class="schema" />

		        <aside class="notes">
			        Think about another way for validators!!!
		        </aside>
	        </section>

          <section>
            <h4>Rework validator</h4>

            <pre><code class="php">class UniqueEntityCodeValidator extends ConstraintValidator {
  private $codeSet = [];

  public function validate($entity, Constraint $constraint) {
    if (isset($this->codeSet[$entity->getCode()])) {
      $this->context
        ->buildViolation($constraint->message)
        ->setParameter('%unique_code%', $entity->getCode())
        ->addViolation();

      return;
    }
    $this->codeSet[$entity->getCode()] = $entity->getCode();
  }
}</code></pre>
          </section>

          <section>
            <h4>Relaunch the import!</h4>

            <h5>Batch size 1</h5>
            <pre><code class="bash">Memory: 6.29M
1001 entity written
Time: 21.24s - Memory: 20.97M - Diff: 14.68M</code></pre>

            <div class="frament">
              <h5>Batch size = 100</h5>
              <pre><code class="bash">Memory: 6.29M
Entity "id-quia" not valid: The value "id-quia" is already set in another entity
1000 entity written
Import - Time: 1.95s - Memory: 20.97M - Diff: 14.68M</code></pre>
            </div>

            <aside class="notes">Nette augmentation des perfs grâce au batch size</aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-update.jpg">
          <section>
            <h2>Update Breweries</h2>

            <pre><code class="yaml">code;name
id-quia;Lorem ipsum dolor sit amet[...]</code></pre>

            <aside class="notes">
              Another file with 1 line<br />
              This file contains a name longer than expected<br />
            </aside>
          </section>

          <section>
            <h4>Update breweries</h4>

            <pre><code class="bash">$ bin/console batch:import:brewery breweries_update.csv --env=prod
Memory: 6.29M
Entity "id-quia" not valid: This value is too long.
  It should have 100 characters or less.
0 entity written

[Doctrine\DBAL\Exception\DriverException]
[Doctrine\DBAL\Driver\PDOException]
[PDOException]
  SQLSTATE[22001]: String data, right truncated:
    1406 Data too long for column 'name' at row 1</code></pre>

            <aside class="notes">
              La validation a bien lieu est remonté, l'objet n'est pas persisté.<br />
	            Mais un update est quand même envoyé.<br />
              Celui-ci a pris du temps à être compris<br />
            </aside>
          </section>

          <section>
            <h4>What happens?!</h4>

            <img src="resources/img/doctrine_batch_schema_step_3.png" class="schema" />

            <aside class="notes">
              Explication du schéma + UOW<br />
              2 façons de faire pour corriger ce problème.<br />
              Détacher mon entity de l'UOW afin qu'elle ne soit pas prise en compte (souvent coûteux en temps de le faire ligne par ligne
            </aside>

          </section>

          <section>
            <h3>Change Tracking Policy</h3>

            <blockquote>
              "It is the process of determining what has changed in managed entities since the last time they were synchronized with the db"
            </blockquote>

            <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html">
              http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html
            </a>

            <aside class="notes">
              Defined per entity<br />
            </aside>
          </section>

          <section>
            <h3>Change Tracking Policy</h3>

            <ul>
              <li>Deferred implicit (default)</li>
              <li>Deferred explicit</li>
              <li>Notify</li>
            </ul>

            <aside class="notes">
              Implicit: Doctrine detects the change by a property-by property comparison at commit time. EntityManager::flush(); everything<br />
              Explicit: Same but need to call explicitely EntityManager::persist(). More efficient ;)<br />
              Notify: You need to implement by yourself the changes using listeners. It's far more efficient.
            </aside>
          </section>

          <section>
            <h4>Deferred explicit implementation</h4>

            <pre><code class="yml">BeerBundle\Entity\Brewery:
  type: entity
  table: brewery
  repositoryClass: BeerBundle\Entity\Repository\EntityRepository
  changeTrackingPolicy: DEFERRED_EXPLICIT</code></pre>

            <aside class="notes">
              Plus explicite (comme son nom l'indique)<br />
              Plus efficace car Doctrine ne va checker les diff que sur ce qu'on lui a dit de persister<br />
              Cela résoud le problème fonctionnel mais il ne résoud pas réellement le problème de scalabilité mais nous verrons ça un peu plus tard.<br />
              La réponse à la scalabilité est de détacher cet objet de l'UOW<br />
              Je trouvais important de vous présenter ce fonctionnement pour mieux comprendre doctrine<br />
            </aside>

          </section>

          <section>
            <h4>Relaunch the job</h4>

            <pre><code class="bash smaller">$ bin/console batch:import:brewery breweries_update.csv --env=prod
Memory: 6.29M
Entity "id-quia" not valid: This value is too long. It should have 100 characters or less.
0 entity written
Time: 0.05s - Memory: 14.68M - Diff: 8.39M</code></pre>

            <img src="resources/gif/dancing_zebra.gif" />

            <aside class="notes">
              Niveau performance, la différence se verra sur une grosse volumétrie<br />
              Si vous avez des erreurs et que vous ne persistez que la moitié des entités<br />
              Le calcul du changeset ne sera pas fait sur toutes ces entités
            </aside>
          </section>
        </section>

        <section data-background="resources/pictures/background-beers.jpg">
          <section>
            <h2>Import Beers (10000k lines)</h2>

            <pre><code class="yaml small">code;name;description;brewery;category
kronenbourg;Kronenbourg;A beer to piss;kronenbourg_brewery;piss
stella;Stella Artois;A beer that does not respect its country;Artois;pils
33_export;33 Export;The best competitor of Kronenbourg;heineken;piss</code></pre>
          </section>

          <section>
            <h4>Import beers (10000 lines)</h4>

            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Memory: 6.29M
10000 entity written
Time: 32.3s - Memory: 92.27M - Diff: 85.98M</code></pre>

            <div class="fragment">
              <h4>Import beers (20000 lines)</h4>

              <pre><code class="bash">$ bin/console batch:import:beer beers_20k.csv --env=prod
Memory: 6.29M
PHP Fatal error:
  Allowed memory size of 134217728 bytes exhausted
  (tried to allocate 20480 bytes)</code></pre>
            </div>

            <aside class="notes">
              Useless to increase PHP memory limit,<br />
              it will probably break later with a bigger file
            </aside>
          </section>

          <section>
            <h4>Memory consumption</h4>

            <img src="resources/img/chart-doctrine-memory-leak.png" />

            <aside class="notes">
              Every 5000 items<br />
              300k items
            </aside>
          </section>

          <section data-background="resources/gif/truck_explosion.gif"></section>

          <section>
            <h3>Explanation memory leak problems</h3>

            <ul>
              <li class="fragment">Increase memory usage</li>
              <li class="fragment">GC is run more often...</li>
              <li class="fragment">and for nothing!</li>
              <li class="fragment">Decrease performance</li>
            </ul>

            <aside class="notes">
              3. not able to free memory<br />
              4. It leads to an increase of CPU usage of the process<br />
              Maybe deep into memory usage and garbage collector in PHP<br />
              How to free the memory of an object<br />
              No object duplication<br />
              It's a link on its address and then a reference counter to know how many time an object is used<br />
              When object is not used anymore, it could be free<br />
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-meminfo.jpg">

          <section>
            <h2>php-meminfo</h2>

            <ul>
              <li>Give insight about PHP memory content</li>
              <li>Free & open source PHP extension</li>
              <li><a href="https://github.com/BitOne/php-meminfo">https://github.com/BitOne/php-meminfo</a></li>
            </ul>

            <aside class="notes">
              License MIT<br />
              Its main goal is to help you understand memory leaks: <br />
              by looking at data present in memory, you can better understand your application behaviour.<br />
              We will take a look deeper using a PHP extension named php-meminfo<br />
            </aside>

          </section>

          <section>
            <h3>php-meminfo: How it works?</h3>

            <ol>
              <li class="fragment">Dump memory content</li>
              <li class="fragment">Analyze content (summary)</li>
              <li class="fragment">Analyze memory for an object type</li>
              <li class="fragment">Analyze memory path for a specific object</li>
            </ol>
          </section>

          <section>
            <h4>Dump memory content</h4>

            <pre><code class="php">// EntityWriter
$this->em->flush();
meminfo_info_dump(fopen('/tmp/doctrine_batch.log', 'w'));</code></pre>

            <pre class="fragment"><code class="json">{
  "header": {
    "memory_usage":89735424,
    "memory_usage_real":92274688,
    "peak_memory_usage":90107432,
    "peak_memory_usage_real":92274688
  },
  "items": {
    "0x7f64be256100" : {
      "type" : "array",
      "size" : "72",
      "symbol_name" : "_GET",
      "is_root" : true,
      "frame" : "BatchBundle\\Job\\Job->execute()",
      "children" : {}
    },
    ...
  }
}</code></pre>

            <aside class="notes">
              Expliquer pourquoi le dump est fait là<br />
              Sorte de fin d'une boucle.<br />
              Et puis ça m'arrange car c'est là qu'est le memory leak
            </aside>
          </section>

          <section>
            <h4>Summarize content</h4>

            <pre><code class="bash">$ bin/analyzer summary /tmp/doctrine_batch.log</code></pre>

            <div class="fragment">
              <table class="small">
                <thead>
                <tr>
                  <td>Type</td>
                  <td>Instances Count</td>
                </tr>
                </thead>
                <tbody>
                <tr><td>BeerBundle\Entity\Brewery</td><td>21000</td></tr>
                <tr><td>BeerBundle\Entity\Category</td><td>20139</td></tr>
                <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
                <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
                <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
                <tr><td>BeerBundle\Entity\Beer</td><td>10000</td></tr>
                </tbody>
              </table>
            </div>

            <aside class="notes">
              Could be Proxies\__CG__\BeerBundle\Entity\Brewery<br />
              La taille mémoire cumulée des objets est également disponible mais masquée ici
            </aside>
          </section>

          <section>
            <h4>Analyze memory for an object type</h4>

            <pre><code class="bash smaller">$ bin/analyzer query -f "class=BeerBundle\\Entity\\Beer" -v /tmp/doctrine_batch.log</code></pre>

            <div class="fragment">
              <table>
                <thead>
                <tr>
                  <td>Item ids</td>
                  <td>Item data</td>
                  <td>Children</td>
                </tr>
                </thead>
                <tbody>
                <tr>
                  <td>0x7f64ab801028</td>
                  <td>
                    Type: object<br />
                    Class: BeerBundle\Entity\Beer<br />
                    [...]
                  </td>
                  <td>
                    id: 0x7f64a8d354e0<br />
                    code: 0x7f64a8d35500<br />
                    [...]<br />
                    brewery: 0x7f64a8d355a0<br />
                    category: 0x7f64a8d355c0
                  </td>
                </tr>
                </tbody>
              </table>
            </div>
          </section>

          <section>
            <h4>Analyze memory path for a specific object</h4>

            <pre><code class="bash">$ bin/analyzer ref-path /tmp/doctrine_batch.log 0x7f64ab801028
Found 3 paths
0x7f64ab801028
&uarr;
1 (0x7f64afa4a920)
&uarr;
BeerBundle\Entity\Beer (0x7f64a8c65c80)
&uarr;
identityMap (0x7f64a8c6d320)
&uarr;
unitOfWork (0x7f64afdbe7c0)
&uarr;
doctrine.orm.default_entity_manager (0x7f64af9c08e0)
&uarr;
services (0x7f64af9c1280)
&uarr;
container (0x7f64be256280)</code></pre>

            <aside class="notes"></aside>
          </section>

          <section>
            <img src="resources/gif/oh_my_god_afraid.gif" />

            <aside class="notes">
              Ask if everything is clear!!!
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-deep_uow.jpg">
          <section>
            <h2>Deep into the UOW</h2>
          </section>

          <section>
            <h3>The identity map</h3>
            <div>
              <ul>
                <li>Stores references to all managed entities</li>
                <li>Entities are grouped by their class name</li>
                <li>Avoid entity duplication</li>
              </ul>
            </div>

            <div class="fragment">
              <pre><code class="php">$this->identityMap[$className][$idHash] = $entity;</code></pre>

              <pre><code class="php">$breweryA = $breweryRepo->findOneBy(['code' => 'id-quia']);
$breweryB = $breweryRepo->findOneBy(['name' => 'Dietrich Group']);
$this->assertSame($breweryA, $breweryB);</code></pre>
            </div>

            <aside class="notes">
              4 status of your entity (New, Managed, Detached, Removed)<br />
              Cache niveau 2 pour identityMap?<br/>
	            Ne signifie pas qu'il n'y a pas de query SQL<br />
            </aside>

          </section>

          <section>
            <h3>Detach versus clear</h3>

            3 ways to remove from the UOW:

            <pre class="fragment"><code class="php">$em->detach($entity);</code></pre>
            <pre class="fragment"><code class="php">$em->clear('BeerBundle\Entiy\Beer');</code></pre>
            <pre class="fragment"><code class="php">$em->clear();</code></pre>

            <aside class="notes">
              detach: Detach an entity from the UOW. Does not remove updateCollections, removeCollections, etc. done by commit();<br />
              clear($className): Detach all entities of the class name<br />
              clear(): Clears UOW
            </aside>
          </section>

          <section>
            <h4>Detach entities</h4>

            <pre><code class="php">$this->em->flush();
$this->em->clear('BeerBundle\Entity\Beer');

// or loop on items and call detach
foreach ($items as $item) {
  $this->em->detach($item);
}</code></pre>

            <h4>Previously:</h4>
            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Time: 21.95s - Memory: 92.27M - Diff: 85.98M</code></pre>

            <div class="fragment">
              <h4>Now:</h4>
              <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Time: 21.89s - Memory: 69.21M - Diff: 62.92M</code></pre>
            </div>

            <aside class="notes">
              A bit less performant on 10k<br />
              Same perf between loop detach and clear($className)
            </aside>
          </section>

          <section>
            <h4>Analyze memory</h4>

            <table class="small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
              <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
              <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
              <tr><td>BeerBundle\Entity\Brewery</td><td>1000</td></tr>
              <tr><td>BeerBundle\Entity\Category</td><td>139</td></tr>
              </tbody>
            </table>

            <aside class="notes">
              Categories and Breweries still in memory but, this number won't increase!
            </aside>
          </section>

          <section>
            <h3>Detach entities</h3>

            <img src="resources/gif/the_office_oh_yeah.gif" />

            <ul class="fragment">
              <li>Categories and Breweries are not detached</li>
              <li>No cascade detach (ManyToOne)</li>
              <li>Not the same lifecycle</li>
            </ul>

            <aside class="notes">
              Categories and Breweries exist without Beers<br />
              Don't want to cascade detach<br />
              Categories needs to stay in the UOW as they can be used by another Beer
            </aside>
          </section>

          <section>
            <h4>Clear UOW</h4>
            <pre><code class="php">$this->em->flush();
$this->em->clear();</code></pre>

            <h4>Previously:</h4>
            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Time: 21.89s - Memory: 69.21M - Diff: 62.92M</code></pre>

            <div class="fragment">
              <h4>Now:</h4>
              <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Time: 22.16s - Memory: 67.11M - Diff: 60.82M</code></pre>
            </div>

            <aside class="notes">
              A bit longer as we rehydrate each time categories and breweries
            </aside>
          </section>

          <section>
            <h4>Clear UOW</h4>
            <table class="small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Doctrine\ORM\Query\ResultSetMapping</td><td>11145</td></tr>
              <tr><td>Doctrine\ORM\Query\ParserResult</td><td>11139</td></tr>
              <tr><td>Doctrine\ORM\Query\Exec\SingleSelectExecutor</td><td>11139</td></tr>
              </tbody>
            </table>

            <img src="resources/gif/barney_stinson_good.gif" />

            <aside class="notes">
              2M less than previous execution<br />
              No more Brewery nor Category<br />
              Not necessary to clear the whole UOW in this case<br />
	            10000 beers + 1000 breweries + 139 categories
            </aside>
          </section>
        </section>

        <section data-background="resources/pictures/background-hunt.jpg">
	        <section>
		        <h2>Let's hunt last memory leaks</h2>

		        <ul class="fragment">
			        <li class="grow">SingleSelectExecutor</li>
			        <li class="grow">ResultSetMapping</li>
			        <li class="grow">ParserResult</li>
		        </ul>

            <aside class="notes">
              1. Executes SQL statement from DQL select statement<br />
              2. Maps results set of SQL query to Doctrine results<br />
              3. Encapsulates results from DQL parsing
            </aside>
	        </section>

	        <section>
		        <h4>Let's hunt last memory leaks</h4>

		        Analyze the memory with php-meminfo:

		        <pre><code class="smaller">Path from 0x7fa5eaa56280
0x7fa5d8f14c00
&uarr;
_resultSetMapping (0x7fa5dc2af5c8)
&uarr;
0 (0x7fa5d9a11000)
&uarr;
sf_orm_default_a1536898803dafe5...35e6d6[72581bc...1c0fa291][1] (0x7fa5d8ee45e0)
&uarr;
data (0x7fa5dc5b9b00)
&uarr;
doctrine_cache.providers.doctrine.orm.default_query_cache (0x7fa5dc1d3060)
&uarr;
services (0x7fa5dc1d3780)
&uarr;
container (0x7fa5eaa56280)</code></pre>

		        <aside class="notes">
              Object linked to ORM\Query
            </aside>
	        </section>

	        <section>
		        <h4>Dedicated repository</h4>

		        <pre><code class="php">public function findOneByIdentifier(string $code) {
    $qb = $this->createQueryBuilder('c');
    $qb->andWhere(
        $qb->expr()->eq('c.code', $qb->expr()->literal($code))
    );

    $results = $qb->getQuery()->execute();
    //...
    return $results[0];
}</code></pre>

            <img src="resources/gif/mister_bean_nawak.gif" class="fragment" />

	        </section>

	        <section>
		        <h4>How to query entities?!</h4>

		        <pre><code class="php">$qb = $this->createQueryBuilder('c');
$qb->andWhere(
  $qb->expr()->eq('c.code', $qb->expr()->literal($code))
);

$results = $qb->getQuery()->execute();</code></pre>

            <div class="fragment">
              <h4>DQL</h4>
              <pre><code class="sql smaller">SELECT c FROM BeerBundle\Entity\Beer c WHERE c.code = 'dolorum-aliquid-maiores'</code></pre>
            </div>
	        </section>

	        <section>
		        <h4>How to query entities?!</h4>

		        <pre><code class="php">$qb = $this->createQueryBuilder('c');
$qb->andWhere(
  $qb->expr()->eq('c.code', ':code')
);
$qb->setParameter('code', $code);

$results = $qb->getQuery()->execute();</code></pre>

            <div class="fragment">
              <h4>DQL</h4>
              <pre><code class="sql">SELECT c FROM BeerBundle\Entity\Beer c WHERE c.code = :code</code></pre>
            </div>

	        </section>

          <section>
            <h4>How to query entities?!</h4>

            <pre><code class="php">public function findOneByIdentifier(string $code) {
    return $this->findOneBy(['code' => $code]);
}</code></pre>
            <ul>
              <li>Uses BasicEntityPersister</li>
              <li>Only work on a single table</li>
            </ul>

            <pre><code class="bash">$ bin/console batch:import:beer beers_10k.csv --env=prod
Memory: 6.29M
Time: 15.9s - Memory: 14.68M - Diff: 8.39M</code></pre>

            <aside class="notes">
              Persister instead of create DQL queries<br />
              Far more efficient<br />
              More about performance<br />
              14.68M
            </aside>
          </section>

          <section>
            <h4>Analyze memory</h4>

            <pre><code class="bash">$ bin/console batch:import:beer beers_1M.csv --env=prod
Memory: 6.29M
Time: 1573.68s - Memory: 14.68M - Diff: 8.39M</code></pre>

            <img src="resources/gif/waouh.gif" />

            <aside class="notes">
              Juste une petite modification sur le validateur<br />
              puisqu'il faut nettoyer le tableau de code uniques après chaque flush<br />
              No more memory leak at this point!<br />
              Don't know why there is so much entities of these types
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-import-summary.jpg">
          <section>
            <h2>Mission accomplished!</h2>

            <img src="resources/gif/cat_shakes.gif" />
          </section>

          <section>
            <h3>In a nutshell</h3>
            <ul>
              <li class="fragment">Use production environment</li>
              <li class="fragment">Find the right moment to flush</li>
              <li class="fragment">Rework validation</li>
              <li class="fragment">Change Tracking Policy</li>
              <li class="fragment">Clear UOW</li>
              <li class="fragment">Take care at your queries</li>
            </ul>
          </section>
        </section>

        <section data-background="resources/pictures/background-export.jpg">
          <section>
            <h2>What about export!</h2>
          </section>

          <section>
            <h4>Command to export beers</h4>

            <pre><code class="php smaller">$filepath = $input->getArgument('filepath');
$fd = fopen($filepath, 'a+');
$headers = ['code', 'name', 'description', 'percent', 'brewery', 'category'];
fputcsv($fd, $headers, ';');

$beers = $this->getBeerRepository()->findAll();
foreach ($beers as $beer) {
    $csvRow = $this->process($beer);
    fputcsv($fd, $csvRow, ';');
}

fclose($fd);</code></pre>
          </section>

          <section>
            <h4>Command to export beers</h4>

            <pre><code class="php smaller">private function process(Beer $beer) {
    $data = [];
    $data['code'] = $beer->getCode();
    $data['name'] = $beer->getName();
    $data['description'] = $beer->getDescription();
    $data['percent'] = $beer->getPercent();
    $data['quotation'] = $beer->getQuotation();
    $data['brewery'] = $beer->getBrewery()->getCode();
    $data['category'] = $beer->getCategory()->getCode();

    return $data;
}</code></pre>
          </section>

          <section>
            <h4>Launch the export</h4>

            <pre><code class="bash">$ bin/console batch:export:beer beers.csv --env=prod
Memory: 6.29M
Time: 0.83s - Memory: 46.14M - Diff: 39.85M</code></pre>

            <table class="fragment small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Brewery</td><td>21000</td></tr>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Category</td><td>20139</td></tr>
              <tr><td>BeerBundle\Entity\Beer</td><td>10000</td></tr>
              </tbody>
            </table>
            <aside class="notes">Proxy class comes from Doctrine lazy load</aside>
          </section>

          <section>
            <h4>Clear the UOW</h4>

            <pre><code class="php">$beers = $this->getBeerRepository()->findAll();
$this->getEntityManager()->clear();
foreach ($beers as $beer) {</code></pre>

            <pre class="fragment"><code class="bash">bin/console batch:export:beer beers.csv --env=prod
Memory: 6.29M
Time: 0.83s - Memory: 46.14M - Diff: 39.85M</code></pre>

            <table class="fragment small">
              <thead>
              <tr>
                <td>Type</td>
                <td>Instances Count</td>
              </tr>
              </thead>
              <tbody>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Brewery</td><td>1000</td></tr>
              <tr><td>Proxies\__CG__\BeerBundle\Entity\Category</td><td>139</td></tr>
              </tbody>
            </table>

            <aside class="notes">
              Better since repository do a clear($className)
            </aside>
          </section>

          <section>
            <h2>Find All</h2>

            <img src="resources/gif/barney_stinson_no.gif" />

            <div class="fragment">
              <ul>
                <li>Take care about findAll</li>
                <li>At least use findBy method</li>
              </ul>

              <pre><code class="php smaller">public function findBy(array $criteria, array $orderBy, $limit, $offset);</code></pre>
            </div>

            <aside class="notes">
              1. This should never be used <br />
              1. Si create autorisé, vous devez faire attention à la volumétrie<br />
              2. findBy uses offset and limit<br />
            </aside>
          </section>

          <section>
            <h4>How to do SQL query on huge table?!</h4>

            <ul>
              <li>Read offset/limit</li>
              <li>Database cursor</li>
              <li>Search after</li>
            </ul>
          </section>

          <section>

            <h4>Read offset/limit</h4>

            <ul>
              <li>Linear increase</li>
              <li>Exponential cost per volume</li>
            </ul><br />

            <img src="resources/img/sql_read_offset_limit.png" width="50%" />

            <aside class="notes"></aside>
          </section>

          <section>
            <h4>Read offset/limit</h4>

            <pre><code class="sql">mysql> SELECT * FROM beer;
1611768 rows in set (3,92 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 0, 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 100000, 100;
100 rows in set (0,09 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer LIMIT 1000000, 100;
100 rows in set (0,83 sec)</code></pre>

            <aside class="notes">
              Besoin de lire le 1er M de lignes pour renvoyer les 100 prochaines<br />
              $qb->setFirstResult et setMaxResult en doctrine
            </aside>
          </section>

          <section>

            <h4>Database cursor</h4>

            <ul>
              <li>No increase</li>
              <li>Linear cost per volume</li>
            </ul><br />

            <img src="resources/img/sql_read_db_cursor.png" width="50%" />

            <aside class="notes">
              once the query had been launched<br />
              the results are made available one by one to the client that launched the query
            </aside>
          </section>

          <section>
            <h4>Database cursor</h4>

            <pre><code class="php">public function __construct(EntityManager $em) {
        $em->getConnection()
            ->getWrappedConnection()
            ->setAttribute(\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
        $this->repository = $em->getRepository('BeerBundle\Entity\Beer');
}

public function read() {
    //...
    $result = $this->results->next();
    if (null !== $result) {
        if (++$this->readCount % 100 === 0)
            $this->repository->clear();
        return $result[0];
    }
}

private function getResults() {
    $qb = $this->repository->createQueryBuilder('b');
    return $qb->getQuery()->iterate();
}</code></pre>
          </section>

          <section>
            <h3>Database cursor</h3>

            <pre><code class="bash">bin/console batch:export:beer beers.csv --env=prod
Memory: 6.29M
Time: 112.78s - Memory: 14.68M - Diff: 8.39M</code></pre>

            <div class="right">
              <div>Inconvenience: Once cursor is opened, not possible to have any other SELECT operations</div>

              <pre><code class="bash smaller">[PDOException]
  SQLSTATE[HY000]: [...]Cannot execute queries while other unbuffered queries are active</code></pre>
            </div>

            <aside class="notes">
              On peut imaginer loader en cache les objets catégories et breweries avant d'itérer<br />
              Avec un findAll()...
            </aside>
          </section>

          <section>
            <h4>Search after</h4>

            <ul>
              <li>No increase</li>
              <li>Linear cost per volume</li>
            </ul><br />

            <img src="resources/img/sql_read_search_after.png" width="50%" />

            <aside class="notes">
              C'est l'échelle qui fait qu'on est sur une courbe non linéaire<br /
              Le problème du Offset-limit c'est de tout relire depuis le début<br />
              Si on recherche après notre dernier résultat, on enlève ce problème<br />
            </aside>
          </section>

          <section>
            <h4>Search after</h4>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 0 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 100000 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <pre class="fragment"><code class="sql">mysql> SELECT * FROM beer WHERE id > 1000000 ORDER BY id ASC LIMIT 100;
100 rows in set (0,00 sec)</code></pre>

            <aside class="notes">
              A vous d'implémenter ça dans le code maintenant :)
            </aside>
          </section>

          <section>
            <h4>Search after</h4>

            <pre><code class="php">private function getResults($id = 0) {
    $qb = $this->repository->createQueryBuilder('b');
    $qb
        ->where($qb->expr()->gt('b.id', ':id'))
        ->orderBy('b.id')
        ->setMaxResults(100)
        ->setParameter('id', $id);

    $this->results = $qb->getQuery()->execute();
}</code></pre>

            <pre><code class="bash fragment">$ bin/console batch:export:beer beers.csv --env=prod
Memory: 6.29M
Time: 132.91s - Memory: 14.68M - Diff: 8.39M</code></pre>

            <aside class="notes">
              20 secondes de plus qu'avec le database cursor<br />
            </aside>
          </section>

        </section>

        <section data-background="resources/pictures/background-whats_next.jpg">
          <h2>What's next?</h2>

          <ul>
            <li>Multi import</li>
            <li>Improve performance</li>
            <li>Mass Delete</li>
          </ul>

          <aside class="notes">
            1. Import brewery + beers at the same time<br />
            2. Change Tracking Policy using notify
          </aside>
        </section>

        <section data-background="resources/pictures/background-thanks.jpg">

          <h2>Thank you</h2>

          <a href="https://github.com/fitn/doctrine-batch/">https://github.com/fitn/doctrine-batch/</a>

          <aside class="notes">
            Retour d'xp d'Akeneo<br />
            J'espère que vous avez appris quelques petits trucs<br />
            Et que vous aurez envie de creuser un peu plus doctrine
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>

  </body>
</html>
